{
  "status" : "pass",
  "tests" : [ {
    "name" : "keyIsLowercaseLetters",
    "test_code" : "@Test\npublic void keyIsLowercaseLetters() {\n    assertThat(cipherWithDefaultKey.getKey()).matches(\"^[a-z]+$\");\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDecode",
    "test_code" : "@Test\npublic void cipherCanDecode() {\n    String cipherText = \"aaaaaaaaaa\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.getKey().substring(0, 10))).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanEncode",
    "test_code" : "/**\n * Here we take advantage of the fact that plaintext of \"aaa...\" doesn't output the key. This is a critical\n * problem with shift ciphers, some characters will always output the key verbatim.\n */\n@Test\npublic void cipherCanEncode() {\n    String plainText = \"aaaaaaaaaa\";\n    String cipherText = cipherWithDefaultKey.getKey().substring(0, 10);\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherIsReversible",
    "test_code" : "@Test\npublic void cipherIsReversible() {\n    String plainText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.encode(plainText))).isEqualTo(plainText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDoubleShiftEncode",
    "test_code" : "@Test\npublic void cipherCanDoubleShiftEncode() {\n    String plainText = \"iamapandabear\";\n    String cipherText = \"qayaeaagaciai\";\n    assertThat(new Cipher(plainText).encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDecode",
    "test_code" : "@Test\npublic void cipherCanDecode() {\n    String plainText = \"abcdefghij\";\n    String cipherText = \"aaaaaaaaaa\";\n    assertThat(cipherWithDefaultKey.decode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanEncode",
    "test_code" : "@Test\npublic void cipherCanEncode() {\n    String plainText = \"aaaaaaaaaa\";\n    String cipherText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherMessageLongerThanKey",
    "test_code" : "@Test\npublic void cipherMessageLongerThanKey() {\n    String plainText = \"iamapandabear\";\n    String key = \"abc\";\n    String cipherText = \"iboaqcnecbfcr\";\n    assertThat(new Cipher(key).encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherIsReversibleGivenKey",
    "test_code" : "@Test\npublic void cipherIsReversibleGivenKey() {\n    String plainText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.encode(plainText))).isEqualTo(plainText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanWrapDecode",
    "test_code" : "@Test\npublic void cipherCanWrapDecode() {\n    String plainText = \"zabcdefghi\";\n    String cipherText = \"zzzzzzzzzz\";\n    assertThat(cipherWithDefaultKey.decode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanWrapEncode",
    "test_code" : "@Test\npublic void cipherCanWrapEncode() {\n    String plainText = \"zzzzzzzzzz\";\n    String cipherText = \"zabcdefghi\";\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDoubleShiftEncode",
    "test_code" : "@Test\npublic void cipherCanDoubleShiftEncode() {\n    String plainText = \"iamapandabear\";\n    String cipherText = \"qayaeaagaciai\";\n    assertThat(new Cipher(plainText).encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDecode",
    "test_code" : "@Test\npublic void cipherCanDecode() {\n    String plainText = \"abcdefghij\";\n    String cipherText = \"aaaaaaaaaa\";\n    assertThat(cipherWithDefaultKey.decode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanEncode",
    "test_code" : "@Test\npublic void cipherCanEncode() {\n    String plainText = \"aaaaaaaaaa\";\n    String cipherText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherMessageLongerThanKey",
    "test_code" : "@Test\npublic void cipherMessageLongerThanKey() {\n    String plainText = \"iamapandabear\";\n    String key = \"abc\";\n    String cipherText = \"iboaqcnecbfcr\";\n    assertThat(new Cipher(key).encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherIsReversibleGivenKey",
    "test_code" : "@Test\npublic void cipherIsReversibleGivenKey() {\n    String plainText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.encode(plainText))).isEqualTo(plainText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanWrapDecode",
    "test_code" : "@Test\npublic void cipherCanWrapDecode() {\n    String plainText = \"zabcdefghi\";\n    String cipherText = \"zzzzzzzzzz\";\n    assertThat(cipherWithDefaultKey.decode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanWrapEncode",
    "test_code" : "@Test\npublic void cipherCanWrapEncode() {\n    String plainText = \"zzzzzzzzzz\";\n    String cipherText = \"zabcdefghi\";\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "keyIsLowercaseLetters",
    "test_code" : "@Test\npublic void keyIsLowercaseLetters() {\n    assertThat(cipherWithDefaultKey.getKey()).matches(\"^[a-z]+$\");\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanDecode",
    "test_code" : "@Test\npublic void cipherCanDecode() {\n    String cipherText = \"aaaaaaaaaa\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.getKey().substring(0, 10))).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherCanEncode",
    "test_code" : "/**\n * Here we take advantage of the fact that plaintext of \"aaa...\" doesn't output the key. This is a critical\n * problem with shift ciphers, some characters will always output the key verbatim.\n */\n@Test\npublic void cipherCanEncode() {\n    String plainText = \"aaaaaaaaaa\";\n    String cipherText = cipherWithDefaultKey.getKey().substring(0, 10);\n    assertThat(cipherWithDefaultKey.encode(plainText)).isEqualTo(cipherText);\n}",
    "status" : "pass"
  }, {
    "name" : "cipherIsReversible",
    "test_code" : "@Test\npublic void cipherIsReversible() {\n    String plainText = \"abcdefghij\";\n    assertThat(cipherWithDefaultKey.decode(cipherWithDefaultKey.encode(plainText))).isEqualTo(plainText);\n}",
    "status" : "pass"
  } ],
  "version" : 3
}